#include "cache.h"
#include <vector>
#include <unordered_set>
#include <deque>
#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <limits>

using namespace std;

// -----------------------------------------------------------
// constants
// -----------------------------------------------------------
static const int LINES_PER_PAGE = (1 << (LOG2_PAGE_SIZE - LOG2_BLOCK_SIZE));
static const int DEFAULT_TABLE_SIZE = 64;   // default table size
static const uint32_t CONF_THRESH = 2;      // min confidence
static const uint32_t FREQ_MIN_FOR_USE = 2; // min freq to consider offset
static const size_t   RECENT_DEMAND_MAX = 4096; // recent demand filter

// -----------------------------------------------------------
// data structures
// -----------------------------------------------------------
struct OffsetEntry {
    int32_t  delta;
    uint32_t freq;
    uint32_t conf;
    OffsetEntry() : delta(0), freq(0), conf(0) {}
};

struct RegionEntry {
    uint64_t page;
    bool     valid;
    int32_t  last_line;
    OffsetEntry top[5]; // keep top-5 candidates
    RegionEntry() : page(0), valid(false), last_line(-1) {}
};

// -----------------------------------------------------------
// globals
// -----------------------------------------------------------
static vector<RegionEntry> region_table;
static int TABLE_SIZE = DEFAULT_TABLE_SIZE;
static bool initialized = false;

// stats
static uint64_t prefetch_issued = 0;
static uint64_t prefetch_useful = 0;

// outstanding prefetch bookkeeping
static unordered_set<uint64_t> outstanding_pf_lines;

// small "recent demands" filter
static unordered_set<uint64_t> recent_demand_set;
static deque<uint64_t> recent_demand_fifo;

// -----------------------------------------------------------
// helpers
// -----------------------------------------------------------
static inline uint64_t page_num(uint64_t addr) {
    return addr >> LOG2_PAGE_SIZE;
}
static inline uint64_t page_base(uint64_t addr) {
    return addr & ~((1ULL << LOG2_PAGE_SIZE) - 1ULL);
}
static inline uint64_t line_addr(uint64_t addr) {
    return addr >> LOG2_BLOCK_SIZE;
}
static inline int32_t line_in_page(uint64_t addr) {
    return (int32_t)((addr >> LOG2_BLOCK_SIZE) & (LINES_PER_PAGE - 1));
}

static inline RegionEntry& get_region(uint64_t pg) {
    size_t idx = (size_t)(pg % TABLE_SIZE);
    RegionEntry &e = region_table[idx];
    if (!e.valid || e.page != pg) {
        e.valid = true;
        e.page = pg;
        e.last_line = -1;
        for (int i=0; i<5; i++) {
            e.top[i] = OffsetEntry();
        }
    }
    return e;
}

static inline void update_offset(RegionEntry &e, int32_t dlt) {
    if (dlt == 0) return;

    for (int i=0; i<5; i++) {
        if (e.top[i].freq != 0 && e.top[i].delta == dlt) {
            if (e.top[i].freq < std::numeric_limits<uint32_t>::max())
                e.top[i].freq++;
            return;
        }
    }

    int replace_idx = -1;
    uint32_t minf = std::numeric_limits<uint32_t>::max();
    for (int i=0; i<5; i++) {
        if (e.top[i].freq == 0) { replace_idx = i; break; }
        if (e.top[i].freq < minf) { minf = e.top[i].freq; replace_idx = i; }
    }
    if (replace_idx >= 0) {
        e.top[replace_idx].delta = dlt;
        e.top[replace_idx].freq  = 1;
        e.top[replace_idx].conf  = 0;
    }
}

struct ByConfThenFreq {
    bool operator()(const OffsetEntry &a, const OffsetEntry &b) const {
        if (a.conf != b.conf) return a.conf > b.conf;
        if (a.freq != b.freq) return a.freq > b.freq;
        return (std::abs(a.delta) < std::abs(b.delta));
    }
};

// mark issued prefetch
static inline void remember_pf(uint64_t pf_addr) {
    outstanding_pf_lines.insert(line_addr(pf_addr));
}

// demand consumes prefetched line
static inline void consume_if_useful(uint64_t addr) {
    uint64_t la = line_addr(addr);

    // recent demand window
    recent_demand_fifo.push_back(la);
    recent_demand_set.insert(la);
    if (recent_demand_fifo.size() > RECENT_DEMAND_MAX) {
        uint64_t victim = recent_demand_fifo.front();
        recent_demand_fifo.pop_front();
        recent_demand_set.erase(victim);
    }

    if (outstanding_pf_lines.find(la) != outstanding_pf_lines.end()) {
        outstanding_pf_lines.erase(la);
        prefetch_useful++;
    }
}

// train on demand
static inline void train_on(uint64_t addr) {
    uint64_t pg = page_num(addr);
    RegionEntry &e = get_region(pg);
    int32_t cur = line_in_page(addr);
    if (e.last_line >= 0) {
        int32_t dlt = cur - e.last_line;
        if (dlt != 0 && dlt > -LINES_PER_PAGE && dlt < LINES_PER_PAGE)
            update_offset(e, dlt);
    }
    e.last_line = cur;
}

// aggressiveness: simple degree control
static inline int compute_degree() {
    double acc = (prefetch_issued == 0) ? 0.0 : (double)prefetch_useful / (double)prefetch_issued;
    if (acc >= 0.80) return 8;
    if (acc >= 0.60) return 6;
    if (acc >= 0.40) return 4;
    if (acc >= 0.20) return 2;
    return 1;
}

// -----------------------------------------------------------
// ChampSim entry points
// -----------------------------------------------------------
void CACHE::l2c_prefetcher_initialize() 
{
    if (initialized) return;

    const char* env = getenv("OFFSET_TABLE");
    if (env) {
        int v = atoi(env);
        if (v == 32 || v == 64 || v == 128) {
            TABLE_SIZE = v;
        }
    }

    region_table.clear();
    region_table.resize(TABLE_SIZE);

    prefetch_issued = 0;
    prefetch_useful = 0;

    outstanding_pf_lines.clear();
    recent_demand_set.clear();
    recent_demand_fifo.clear();

    initialized = true;

    cout << "L2 offset prefetcher active (table size=" 
         << TABLE_SIZE << ")" << endl;
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip,
                                       uint8_t cache_hit, uint8_t type,
                                       uint32_t metadata_in,
                                       uint8_t critical_ip_flag)
{
    if (!initialized) l2c_prefetcher_initialize();

    if (type == 0) consume_if_useful(addr);

    if (type == 0) {
        train_on(addr);

        uint64_t pg = page_num(addr);
        RegionEntry &e = get_region(pg);

        vector<OffsetEntry> cand;
        for (int i=0; i<5; i++) {
            if (e.top[i].freq >= FREQ_MIN_FOR_USE || e.top[i].conf >= CONF_THRESH)
                cand.push_back(e.top[i]);
        }
        if (cand.empty()) return metadata_in;

        sort(cand.begin(), cand.end(), ByConfThenFreq());

        int deg = compute_degree();
        int32_t cur_line = line_in_page(addr);
        uint64_t base = page_base(addr);

        int issued = 0;
        for (size_t k = 0; k < cand.size() && issued < deg; ++k) {
            int32_t target = cur_line + cand[k].delta;
            if (target < 0 || target >= LINES_PER_PAGE) continue;

            uint64_t pf_addr = base | ((uint64_t)target << LOG2_BLOCK_SIZE);
            uint64_t pf_line = line_addr(pf_addr);

            if (pf_addr == addr) continue;
            if (outstanding_pf_lines.find(pf_line) != outstanding_pf_lines.end()) continue;
            if (recent_demand_set.find(pf_line) != recent_demand_set.end()) continue;

            if (prefetch_line(ip, addr, pf_addr, FILL_L2, 0)) {
                prefetch_issued++;
                remember_pf(pf_addr);
                issued++;
            }
        }
    }

    return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set,
                                          uint32_t match, uint8_t prefetch,
                                          uint64_t evicted_addr,
                                          uint32_t metadata_in)
{
    return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
    if (!initialized) return;

    double acc = (prefetch_issued == 0) ? 0.0 : (double)prefetch_useful / (double)prefetch_issued;

    cout << "=== L2 Offset Prefetcher Stats ===" << endl;
    cout << "Prefetches issued : " << prefetch_issued << endl;
    cout << "Prefetches useful : " << prefetch_useful << endl;
    cout << "Accuracy          : " << acc << endl;
    cout << "Table size        : " << TABLE_SIZE << endl;
    cout << "CONF_THRESH       : " << CONF_THRESH << endl;
    cout << "==================================" << endl;
}